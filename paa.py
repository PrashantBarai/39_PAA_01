# # from flask import Flask, render_template, request
# # from sklearn.feature_extraction.text import TfidfVectorizer
# # from sklearn.ensemble import RandomForestClassifier
# # import pandas as pd
# # import numpy as np
# # data = pd.DataFrame({
# #     'text': [
# #         'This is a human-written text.',
# #         'This text might be generated by AI.',
# #         'Another human-written text here.',
# #         'AI-generated text for testing purposes.'
# #     ],
# #     'category': [1, 0, 1, 0]
# # })
# # # Sample input text
# # i = ['This is a human']
# #
# # # Initialize Flask app
# # app = Flask(__name__)
# #
# # # Load the pre-trained model and vectorizer
# # vectorizer = TfidfVectorizer()
# # rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
# #
# # # Assuming 'data' is your DataFrame containing 'text' and 'category' columns
# # input_text = data['text']
# # y_train = data['category']
# #
# # # Vectorize the input text
# # X_train_tfidf = vectorizer.fit_transform(input_text)
# # X_train = X_train_tfidf.toarray()
# #
# # # Fit the classifier to the training data
# # rf_classifier.fit(X_train, y_train)
# #
# #
# # @app.route('/', methods=['GET', 'POST'])
# # def home():
# #     if request.method == 'POST':
# #         # Get input text from the form
# #         input_text = request.form['text']
# #
# #         # Transform the input text to a feature vector
# #         input_vector = vectorizer.transform([input_text]).toarray()
# #
# #         # Predict using the trained classifier
# #         prediction = rf_classifier.predict(input_vector)
# #
# #         # Convert prediction to human-readable label
# #         label = "AI-generated" if prediction[0] == 0 else "Human-written"
# #
# #         return render_template('result.html', prediction=label, text=input_text)
# #
# #     return render_template('paa.html')
# #
# # @app.route('/predict', methods=['POST'])
# # def predict():
# #     # Get input text from the form
# #     input_text = [request.form['text']]
# #
# #     # Transform the input text to a feature vector
# #     input_vector = vectorizer.transform(input_text).toarray()
# #
# #     # Predict using the trained classifier
# #     prediction = rf_classifier.predict(input_vector)
# #
# #     # Convert prediction to human-readable label
# #     label = "AI-generated" if prediction[0] == 0 else "Human-written"
# #
# #     return render_template('result.html', prediction=label, text=input_text[0])
# #
# #
# # if __name__ == '__main__':
# #     app.run(debug=True)
# from flask import Flask, render_template, request
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.ensemble import RandomForestClassifier
# import pandas as pd
# import numpy as np
# import nltk
# from nltk.tokenize import sent_tokenize
#
# # Download nltk data
# nltk.download('punkt')
#
# # Initialize Flask app
# app = Flask(__name__)
#
# # Load the pre-trained model and vectorizer
# vectorizer = TfidfVectorizer()
# rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
#
# # Sample input text
# input_text = ['This is a human']
#
# # Assuming 'data' is your DataFrame containing 'text' and 'category' columns
# data = pd.DataFrame(columns=['text', 'category'])
#
# # Fit the classifier to the training data
# X_train_tfidf = vectorizer.fit_transform(input_text)
# X_train = X_train_tfidf.toarray()
# y_train = np.array([1])  # Assuming one class for demonstration
# rf_classifier.fit(X_train, y_train)
#
#
# def process_input_text(input_text):
#     sentences = sent_tokenize(input_text)
#     return pd.DataFrame({'text': sentences})
#
#
# @app.route('/', methods=['GET', 'POST'])
# def home():
#     if request.method == 'POST':
#         # # Get input text from the form
#         # input_text = request.form['text']
#         #
#         # # Process input text and store in DataFrame
#         # df = process_input_text(input_text)
#         #
#         # # Transform the input text to a feature vector
#         # input_vector = vectorizer.transform(df['text']).toarray()
#         #
#         # # Predict using the trained classifier
#         # prediction = rf_classifier.predict(input_vector)
#         #
#         # # Convert prediction to human-readable label
#         # labels = ["Human-written" if p == 1 else "AI-generated" for p in prediction]
#         #
#         # return render_template('result.html', predictions=zip(df['text'], labels))
#
#     return render_template('paa.html')
#
# @app.route('/predict')
# def result():
#     return render_template('result.html')
#
#
# if __name__ == '__main__':
#     app.run(debug=True)
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.ensemble import RandomForestClassifier
# import numpy as np
#
# # Sample input text
# text = [
#       'This is a human'
#
#     # 'To resolve this issue, you need to reshape your input data appropriately to match the expected input shape of your model. If your input data has shape',
#               # 'To use Random Forest in scikit-learn for your text classification model, you can follow a similar approach as you did with Logistic Regression.'
#    ]
# input_text = text[0]
#
# vectorizer = TfidfVectorizer()
# # X_train_tfidf = vectorizer.fit_transform(input_text)
# # X_train = X_train_tfidf.toarray()
# # y_train = data['category']
# #
# rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
# #
# # rf_classifier.fit(X_train, y_train)
# input_vector = vectorizer.transform(text).toarray()
#
# prediction = rf_classifier.predict(input_vector)
#
# print("Prediction:", prediction)
# from sklearn.feature_extraction.text import TfidfVectorizer
# from sklearn.ensemble import RandomForestClassifier
# import joblib
#
# class TextClassifierCLI:
#     def __init__(self, model_path='model.joblib'):
#         self.model_path = model_path
#         self.vectorizer = TfidfVectorizer()
#         self.model = RandomForestClassifier(n_estimators=100, random_state=42)
#
#     def load_model(self):
#         # Load the pre-trained model
#         self.model = joblib.load(self.model_path)
#
#     def preprocess_input(self, text):
#         # You can add any preprocessing steps here
#         return text
#
#     def predict(self, text):
#         # Transform input text to a feature vector
#         input_vector = self.vectorizer.transform([text]).toarray()
#
#         # Make predictions using the loaded model
#         prediction = self.model.predict(input_vector)
#
#         return prediction
#
# if __name__ == "__main__":
#     text_classifier = TextClassifierCLI()
#
#     text_classifier.load_model()
#     input_text = input("Enter the text to classify: ")
#
#     preprocessed_text = text_classifier.preprocess_input(input_text)
#
#     prediction = text_classifier.predict(preprocessed_text)
#     print("Prediction:", prediction)


import streamlit as st
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.ensemble import RandomForestClassifier
import joblib
import keras

class TextClassifier:
    def __init__(self, model_path='C:/Users/Ammar1/Downloads/AI_Content_Authenticity_Challenge/AI_Content_Authenticity_Challenge/39_PAA_01/model.joblib'):
        self.model_path = model_path
        self.vectorizer = TfidfVectorizer()
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)

    def load_model(self):
        # Load the pre-trained model
        self.model = joblib.load(self.model_path)

    def preprocess_input(self, text):
        # You can add any preprocessing steps here
        return text

    def predict(self, text):
        # Transform input text to a feature vector
        input_vector = self.vectorizer.transform([text]).toarray()

        # Make predictions using the loaded model
        prediction = self.model.predict(input_vector)

        return prediction

def main():
    st.title("Text Classification")

    # Load the model
    classifier = TextClassifier()
    classifier.load_model()

    # Get user input
    input_text = st.text_area("Enter the text to classify:")

    if st.button("Classify"):
        # Preprocess input
        preprocessed_text = classifier.preprocess_input(input_text)

        # Get prediction
        prediction = classifier.predict(preprocessed_text)[0]

        # Display result
        result = "AI-generated" if prediction == 0 else "Human-written"
        st.write("Prediction:", result)

if __name__ == "__main__":
    main()
